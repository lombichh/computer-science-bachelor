-- Esercizio 1

/* init */
CREATE TABLE R (
	A INT NOT NULL PRIMARY KEY,
	C INT
)

CREATE TABLE S (
	B INT NOT NULL PRIMARY KEY,
	C INT
)

/* 1. Garantire l’unicità dei valori di R.C */
CREATE OR REPLACE TRIGGER CUnicity
BEFORE INSERT ON R
REFERENCING NEW AS NEWR
FOR EACH ROW
WHEN (NEWR.C IN
	(
		SELECT C
		FROM R
	))
SIGNAL SQLSTATE '70000' ('È già presente una tupla con lo stesso valore in C')

/* 2. Imporre il vincolo di integrità referenziale su S.C */
CREATE OR REPLACE TRIGGER CForeignKeyInsert
BEFORE INSERT ON S
REFERENCING NEW AS NEWS
FOR EACH ROW
WHEN (NOT(NEWS.C IN
	(
		SELECT C
		FROM R
	))
)
SIGNAL SQLSTATE '70001' ('Non è presente una tupla in R con lo stesso valore in C')

CREATE OR REPLACE TRIGGER CForeignKeyUpdate
BEFORE UPDATE ON S
REFERENCING NEW AS NEWS
FOR EACH ROW
WHEN (NOT(NEWS.C IN
	(
		SELECT C
		FROM R
	))
)
SIGNAL SQLSTATE '70002' ('Non è presente una tupla in R con lo stesso valore in C')

/* 3. Gestire una politica di cancellazione in cascata su S quando vengono
cancellate tuple di R */
CREATE OR REPLACE TRIGGER CForeignKeyInsert
BEFORE INSERT ON S
REFERENCING NEW AS NEWS
FOR EACH ROW
WHEN (NOT(NEWS.C IN
	(
		SELECT C
		FROM R
	))
)
SIGNAL SQLSTATE '70003' ('Non è presente una tupla in R con lo stesso valore in C')

CREATE OR REPLACE TRIGGER CDeleteCascade
AFTER DELETE ON R
REFERENCING OLD AS OLDR
FOR EACH ROW
DELETE FROM S
WHERE S.C = OLDR.C

-- Esercizio 2

/* init */
DROP TABLE PRODOTTI;
DROP TABLE ORDINI;
DROP TABLE VENDITE;

CREATE TABLE PRODOTTI(
    PCODE 	 CHAR(5) NOT NULL PRIMARY KEY,  	
    DESCRIZIONE VARCHAR(20) NOT NULL,
	PREZZO 	 DEC(6,2) NOT NULL CHECK (PREZZO > 0)	);

CREATE TABLE ORDINI(
	ID 		 CHAR(5) NOT NULL PRIMARY KEY,
	NOMECLIENTE VARCHAR(20) NOT NULL,
	SPESESPEDIZIONE DEC(6,2) NOT NULL DEFAULT 7 CHECK (SPESESPEDIZIONE = 7), 
	TOTALE 	 DEC(6,2) NOT NULL CHECK (TOTALE >=0)	);	

CREATE TABLE VENDITE(
	PCODE 	 CHAR(5) NOT NULL REFERENCES PRODOTTI,
	ID 		 CHAR(5) NOT NULL REFERENCES ORDINI,
	QUANTITA INT NOT NULL CHECK (QUANTITA > 0),
	PRIMARY KEY (PCODE,ID)						);

INSERT INTO PRODOTTI 
VALUES (1, '1', 10),
	(2, '2', 20),
	(3, '3', 30),
	(4, '4', 40)

INSERT INTO ORDINI 
VALUES (1, '1', 7, 0),
	(2, '2', 7, 0),
	(3, '3', 7, 0)

INSERT INTO VENDITE
VALUES (1, 1, 3),
	(1, 2, 2),
	(2, 2, 3)

/* Ogni ordine prevede delle spese di spedizione fisse di 7€ (valore di
default e unico valore ammesso), che vanno considerate nel Totale */
CREATE OR REPLACE TRIGGER InitSpeseSpedizione
AFTER INSERT ON ORDINI
REFERENCING NEW AS NEWORDINE
FOR EACH ROW
UPDATE ORDINI
SET TOTALE = SPESESPEDIZIONE
WHERE ID = NEWORDINE.ID

/* 1. Quando si inseriscono nuovi prodotti nell’ordine */
CREATE OR REPLACE TRIGGER InsertVendite
AFTER INSERT ON VENDITE
REFERENCING NEW AS NEWVENDITA
FOR EACH ROW
UPDATE ORDINI o
SET o.TOTALE = o.TOTALE + NEWVENDITA.QUANTITA * (
	SELECT PREZZO
	FROM PRODOTTI
	WHERE PCODE = NEWVENDITA.PCODE
)
WHERE o.ID = NEWVENDITA.ID

/* 2. Quando si modifica (in più o in meno) la quantità di un prodotto (che
deve essere comunque sempre maggiore di zero) */
CREATE OR REPLACE TRIGGER UpdateVendite
AFTER UPDATE ON VENDITE
REFERENCING NEW AS NEWVENDITA OLD AS OLDVENDITA
FOR EACH ROW
UPDATE ORDINI o
SET o.TOTALE = o.TOTALE + (NEWVENDITA.QUANTITA - OLDVENDITA.QUANTITA) * (
	SELECT PREZZO
	FROM PRODOTTI
	WHERE PCODE = NEWVENDITA.PCODE
)
WHERE o.ID = NEWVENDITA.ID

UPDATE VENDITE
SET QUANTITA = 3
WHERE PCODE = 1 AND ID = 2

/* 3. Quando si eliminano prodotti dall’ordine */
CREATE OR REPLACE TRIGGER DeleteVendite
AFTER DELETE ON VENDITE
REFERENCING OLD AS OLDVENDITA
FOR EACH ROW
UPDATE ORDINI o
SET o.TOTALE = o.TOTALE - OLDVENDITA.QUANTITA * (
	SELECT PREZZO
	FROM PRODOTTI
	WHERE PCODE = OLDVENDITA.PCODE
)
WHERE o.ID = OLDVENDITA.ID

DELETE FROM VENDITE 
WHERE PCODE = 1 AND ID = 1

-- Esercizio 3

/* init */
CREATE TABLE STUDENTI(
	MATR CHAR(6) NOT NULL PRIMARY KEY,  -- CHAR(6) solo per brevita'
	NOME VARCHAR(30) NOT NULL,
	COGNOME VARCHAR(30) NOT NULL					);

CREATE TABLE CORSI (
    CODC CHAR(3) NOT NULL PRIMARY KEY,
	NOME VARCHAR(30) NOT NULL 					);

CREATE TABLE APPELLI (
    CODC CHAR(3) NOT NULL REFERENCES CORSI,
	DATA DATE NOT NULL, 
	LUOGO VARCHAR(30) NOT NULL,
	PRIMARY KEY (CODC, DATA)					);

CREATE TABLE ESAMI (
	MATR CHAR(6) NOT NULL REFERENCES STUDENTI,
        CODC CHAR(3) NOT NULL,
	DATA DATE NOT NULL, 
	VOTO INT NOT NULL CHECK (VOTO BETWEEN 0 AND 31),
	ACCETTATO CHAR(1) DEFAULT NULL CHECK (ACCETTATO = 'Y'),
	FOREIGN KEY (CODC, DATA) REFERENCES APPELLI,
	PRIMARY KEY (MATR, CODC, DATA)					);

CREATE TABLE VERBALIZZAZIONI (
	MATR CHAR(6) NOT NULL REFERENCES STUDENTI,
  	CODC CHAR(3) NOT NULL,
	DATA DATE NOT NULL, 
	VOTO INT NOT NULL CHECK (VOTO BETWEEN 18 AND 31),
	FOREIGN KEY (CODC, DATA) REFERENCES APPELLI,
	PRIMARY KEY (MATR, CODC)					);

INSERT INTO STUDENTI
VALUES (1, '1', '1'),
	(2, '2', '2'),
	(3, '3', '3')
	
INSERT INTO CORSI
VALUES (1, '1'),
	(2, '2')

INSERT INTO APPELLI
VALUES (1, '1.1.2000', '1'),
	(2, '1.1.2000', '2'),
	(2, '1.1.2001', '2')

INSERT INTO ESAMI
VALUES (1, 1, '1.1.2000', 27, NULL),
	(1, 1, '1.1.2001', 29, NULL)

/* 1. Quando si accetta un Voto (Accettato si aggiorna dal valore di default NULL a 'Y'),
si inseriscono con un trigger in VERBALIZZAZIONI i dati corrispondenti all'esame scelto */

CREATE OR REPLACE TRIGGER AggiungiVerbalizzazione
AFTER UPDATE ON ESAMI
REFERENCING NEW AS NEWESAME OLD AS OLDESAME
FOR EACH ROW
WHEN (OLDESAME.ACCETTATO IS NULL
	AND NEWESAME.ACCETTATO = 'Y')
INSERT INTO VERBALIZZAZIONI
VALUES (NEWESAME.MATR, NEWESAME.CODC, NEWESAME.DATA, NEWESAME.VOTO)
	
/* 2. Dopo la verbalizzazione di un voto tutti gli esami relativi alla relativa coppia (studente, corso)
vanno cancellati da ESAMI mediante un trigger */
CREATE OR REPLACE TRIGGER RimuoviEsameVerbalizzato
AFTER UPDATE ON ESAMI
REFERENCING NEW AS NEWESAME OLD AS OLDESAME
FOR EACH ROW
WHEN (OLDESAME.ACCETTATO IS NULL
	AND NEWESAME.ACCETTATO = 'Y')
DELETE FROM ESAMI
WHERE (MATR, CODC) = (NEWESAME.MATR, NEWESAME.CODC)

UPDATE ESAMI
SET ACCETTATO = 'Y'
WHERE MATR = 1
	AND CODC = 1
	AND DATA = '1.1.2001'
	
/* 3. Non deve essere possibile, per uno stesso studente, accettare 2 o più voti di più esami di uno
stesso corso (al max una 'Y' per una coppia (studente, corso))  */
CREATE OR REPLACE TRIGGER VietaAccettazioneDueEsamiUguali
AFTER UPDATE ON ESAMI
REFERENCING NEW AS NEWESAME
FOR EACH ROW
WHEN (EXISTS (SELECT *
	FROM ESAMI
	WHERE (MATR, CODC) = (NEWESAME.MATR, NEWESAME.CODC)
	AND NOT(DATA = NEWESAME.DATA)
	AND ACCETTATO = 'Y'))
SIGNAL SQLSTATE '70004' ('Non è consentito accettare due esami con stessa coppia (studente, corso)');

UPDATE ESAMI
SET ACCETTATO = 'Y'
WHERE MATR = 1
	AND CODC = 1

/* 4. Non deve essere possibile inserire direttamente in ESAMI il valore Accettato = 'Y' */
CREATE OR REPLACE TRIGGER VietaInserimentoEsameVerbalizzato
AFTER INSERT ON ESAMI
REFERENCING NEW AS NEWESAME
FOR EACH ROW 
WHEN (NEWESAME.ACCETTATO IS NOT NULL)
SIGNAL SQLSTATE '70005' ('Non è consentito inserire esami con scelta di accettazione.');

INSERT INTO ESAMI
VALUES ('1', '1', '1.1.2000', 30, 'Y');